# 常用琐碎知识，复制粘贴方便

## yum

```shell
#  配置阿里云yum源，epel源，docker-ce源
wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
sed -i 's+download.docker.com+mirrors.aliyun.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo
yum clean all
yum makecache
```

**列出当前可用的YUM仓库**

```bash
yum repolist
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
repo id             repo name                                              status
base/7/x86_64       CentOS-7 - Base                                        10,072
epel/x86_64         Extra Packages for Enterprise Linux 7 - x86_64         13,770
		#	repo id：库的唯一标识符。
		#	repo name：库的名称。
		#	status：库的状态，包括库中包的数量和库是否已经被检查。

yum repolist all
		#这个命令将会显示所有的库，无论它们是启用还是禁用。对于每个库，它还会显示它们的状态，例如 enabled 或 disabled。
```

**列出所有已安装的软件包**

```shell
yum list installed
```

**查看 yum 已安装 php 的包**

```shell
yum list installed php*
```

**yum下载软件的安装包和其相关依赖**

```bash
# 如果你还没有安装 yumdownloader，你需要首先安装它
yum install yum-utils  

yumdownloader --resolve lsof vim lrzsz -y
--resolve: 这个选项让 yumdownloader 自动解析并下载所需要的依赖包
lsof vim lrzsz: 这些是你想要下载的软件包的名称。
-y: 这个选项让 yumdownloader 在执行命令时不需要用户确认。
```

---

## 查看安全日志

#### 查看成功登录的IP 和次数

```bash
[root@test ~]# cat /var/log/secure* |grep 'Accepted password' |awk '{print $(NF-3)}' |sort -n |uniq -c |awk '{print $2,"成功登录了 "$1," 次"}'
```

#### 查看失败登录的IP和次数

```bash
[root@test ~]# cat /var/log/secure* |grep 'Failed password' |awk '{print $(NF-3)}' |sort -n |uniq -c |awk '{print $2,"登录失败了: "$1," 次"}'
```



## 硬件资源

#### top命令



##### top参数详解

```bash

　　s- 改变画面更新频率

　　l - 关闭或开启第一部分第一行 top 信息的表示

　　t - 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示

　　m - 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示

　　N - 以 PID 的大小的顺序排列表示进程列表（第三部分后述）

　　P - 以 CPU 占用率大小的顺序排列进程列表 （第三部分后述）

　　M - 以内存占用率大小的顺序排列进程列表 （第三部分后述）

　　h - 显示帮助

　　n - 设置在进程列表所显示进程的数量

　　q - 退出 top

　　s -改变画面更新周期
```

##### top查看cpu信息和内存信息

```bash
top

top - 00:15:46 up 48 days,  8:39,  3 users,  load average: 0.07, 0.10, 0.17
Tasks: 219 total,   2 running, 217 sleeping,   0 stopped,   0 zombie
%Cpu(s):  6.8 us,  2.7 sy,  0.0 ni, 89.0 id,  0.0 wa,  0.0 hi,  0.1 si,  1.4 st
KiB Mem :  8008648 total,   262380 free,  4203884 used,  3542384 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  3087740 avail Mem 




第一行（top）：
　　00:15:46  系统当前时刻
　　48 days 系统启动后到现在的运作时间
　　3 users 当前登录到系统的用户，更确切的说是登录到用户的终端数 -- 同一个用户同一时间对系统多个终端的连接将被视为多个用户连接到系统，这里的用户数也将表现为终端的数目
　　load average 当前系统负载的平均值，后面的三个值分别为1分钟前、5分钟前、15分钟前进程的平均数，一般的可以认为这个数值超过 CPU 数目时，CPU 将比较吃力的负载当前系统所包含的进程


第二行（Tasks）：
　　219 total 当前系统进程总数
　　2 running 当前运行中的进程数
　　217 sleeping 当前处于等待状态中的进程数
　　0 stoped 被停止的系统进程数
　　0 zombie 僵尸进程数


第三行（Cpus）：
	7.4% us — 用户空间占用CPU的百分比。
	0.0% sy — 内核空间占用CPU的百分比。
	0.0% ni — 改变过优先级的进程占用CPU的百分比
	92.5% id — 空闲CPU百分比
	0.0% wa — 因为IO等待造成占用CPU的百分比
	0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比
	0.0% si — 软中断（Software Interrupts）占用CPU的百分比
    0.0% st - CPU等待虚拟机调度的时间占比，这个指标一般在虚拟机中才有，在物理机中该值一般为0
　　

第四行（Mem）：
　　8008648 total 物理内存总量
　　262380 used 使用的物理内存总量
　　4203884 free 空闲内存总量
　　3542384 buffers 用作内核缓存的内存量

第五行（Swap）：
#表示类别同第四行（Mem），但此处反映着交换分区（Swap）的使用情况。通常，交换分区（Swap）被频繁使用的情况，将被视作物理内存不足而造成的。
　　0 total 交换区总量
　　0 used 使用的交换区总量
　　0 free 空闲交换区总量
　　0 cached 缓冲的交换区总量
　　
```







#### iotop



查看TPS和吞吐量信息

```shell
iostat -d -k 1 3
Linux 3.10.0-1160.76.1.el7.x86_64 (ansible-mysql) 	11/16/2022 	_x86_64_	(2 CPU)

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               0.53         0.36         5.60     524043    8043652

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               0.00         0.00         0.00          0          0




Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               0.00         0.00         0.00          0          0



d：显示某块具体硬盘，这里没有给出硬盘路径就是默认全部了
-k：以KB为单位显示
1：统计间隔为1秒
3：共统计3次的
tps：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。“一次传输”请求的大小是未知的。
kB_read/s：每秒从设备（drive expressed）读取的数据量；kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；kB_read：读取的总数据量；kB_wrtn：写入 的总数量数据量；这些单位都为Kilobytes。
一开始的数值很大是因为显示的是累计读写量。
```





#### sar

**sar（System Activity Reporter系统活动情况报告）是目前 Linux 上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程等。**

语法：

**sar [options] [-A] [-o file] t [n]**

```shell
sar命令的选项很多，下面只列出常用选项： 
-A：所有报告的总和。　　　　　　　　
-u：CPU利用率　　　　　　　　
-v：进程、I节点、文件和锁表状态。　　　　　　　　
-d：每一个块设备使用情况。　　　　　　　　
-r：内存和交换空间。　　　　　　　

-g：串口I/O的情况。 
-b：查看硬盘读写情况。 
-a：文件读写情况。 
-c：系统调用情况。 
-R：进程的活动情况。 
-y：终端设备活动情况。 
-w：系统交换活动。
```

##### sar查看cpu

```bash
# 查看所有cpu使用情况，每1秒采集一次CPU使用率，共采集5次
sar -u 1 5
Linux 3.10.0-1160.el7.x86_64 (gitlab) 	07/31/2022 	_x86_64_	(4 CPU)

12:11:26 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle
12:11:27 AM     all      7.11      0.00      1.78      0.25      0.76     90.10
12:11:28 AM     all      3.30      0.00      1.52      0.00      0.76     94.42
12:11:29 AM     all      2.82      0.00      1.54      0.00      1.28     94.36
12:11:30 AM     all      3.84      0.00      2.05      0.00      0.77     93.35
12:11:31 AM     all      2.26      0.00      1.00      0.00      1.00     95.74
Average:        all      3.86      0.00      1.58      0.05      0.91     93.60


# 查看指定显示1号cpu 的使用情况，每1秒采集一次CPU使用率，共采集5次
sar -P 1 -u 1 5
Linux 3.10.0-1160.el7.x86_64 (gitlab) 	07/31/2022 	_x86_64_	(4 CPU)

12:12:10 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle
12:12:11 AM       1      1.00      0.00      2.00      0.00      2.00     95.00
12:12:12 AM       1      2.00      0.00      1.00      0.00      2.00     95.00
12:12:13 AM       1     20.20      0.00      2.02      0.00      0.00     77.78
12:12:14 AM       1      3.06      0.00      0.00      0.00      0.00     96.94
12:12:15 AM       1      3.03      0.00      2.02      0.00      1.01     93.94
Average:          1      5.85      0.00      1.41      0.00      1.01     91.73

#参数解释：  
  
%user：显示在用户级别(application)运行使用 CPU 总时间的百分比  
%nice：显示在用户级别，用于nice操作，所占用 CPU 总时间的百分比  
%system：在核心级别(kernel)运行所使用 CPU 总时间的百分比  
%iowait：显示用于等待I/O操作占用 CPU 总时间的百分比  
%idle：显示 CPU 空闲时间占用 CPU 总时间的百分比  

#以下是三种常见的场景：
   1）若 %iowait 的值过高，表示硬盘存在I/O瓶颈
   2）若 %idle 的值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量
   3）若 %idle 的值持续低于1，则系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU
```

##### sar查看内存

```bash
sar -r 5 4 
Linux 3.10.0-1160.el7.x86_64 (gitlab) 	07/31/2022 	_x86_64_	(4 CPU)

12:39:45 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
12:39:50 AM    209448   7799200     97.38    163000   3086128   6621856     82.68   5525224   1600276       188
12:39:55 AM    211692   7796956     97.36    163000   3086168   6622044     82.69   5523608   1600316       304
12:40:00 AM    201168   7807480     97.49    163000   3086276   6622044     82.69   5534384   1600364       416
12:40:05 AM    221568   7787080     97.23    163000   3086296   6620800     82.67   5513964   1600384       456
Average:       210969   7797679     97.37    163000   3086217   6621686     82.68   5524295   1600335       341

#参数解释：  
kbmemfree：剩余可用内存、单位K  
kbmemused：已用内存、以K 为单位、该值不考虑内核自身所使用的内存  
%memused：已用内存百分比  
kbbuffers：已用buffer(内核所用)、单位K  
kbcached：已用cache（内核所用）、单位K  
kbswpfree：剩余Swap、单位K  
kbswpused：已用Swap、单位K  
%swpused：已用Swap百分比  
kbswpcad：被缓存的Swap、单位K  
```

##### **sar监测网卡速度**

```bash
sar -n DEV 1

Linux 3.10.0-1160.el7.x86_64 (gitlab) 	07/31/2022 	_x86_64_	(4 CPU)

12:42:59 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
12:43:00 AM veth2707ccd      0.00      0.00      0.00      0.00      0.00      0.00      0.00
12:43:00 AM veth1530445      0.00      0.00      0.00      0.00      0.00      0.00      0.00
12:43:00 AM vethdf37848      0.00      0.00      0.00      0.00      0.00      0.00      0.00
12:43:00 AM      eth0     23.00      0.00      1.46      0.00      0.00      0.00      0.00
12:43:00 AM      eth1    108.00      0.00      6.41      0.00      0.00      0.00      0.00
12:43:00 AM veth4456dfb      1.00      0.00      0.07      0.00      0.00      0.00      0.00
12:43:00 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
12:43:00 AM veth3541656      0.00      0.00      0.00      0.00      0.00      0.00      0.00
12:43:00 AM veth4e64e35      0.00      0.00      0.00      0.00      0.00      0.00      0.00
12:43:00 AM   docker0      1.00      0.00      0.06      0.00      0.00      0.00      0.00

#参数解释：  
rxpck/s：每秒接收数据包的数量
txpck/s：每秒发送数据包的数量
rxkb/s：每秒接收的数据大小，单位kb
txkb/s：每秒发送的数据大小，单位kb
rxcmp/s：每秒接收的压缩包的数量
txcmp/s：每秒发送的压缩包的数量
rxmcst/s：每秒接收的多播数据包数量
```

##### sar监测磁盘IO

```bash
sar -b 3 5 

Linux 3.10.0-1160.el7.x86_64 (gitlab) 	07/31/2022 	_x86_64_	(4 CPU)

12:45:56 AM       tps      rtps      wtps   bread/s   bwrtn/s
12:45:59 AM     10.33      0.00     10.33      0.00    320.00
12:46:02 AM      0.00      0.00      0.00      0.00      0.00
12:46:05 AM     10.33      0.00     10.33      0.00    141.33
12:46:08 AM      1.67      0.00      1.67      0.00     88.00
12:46:11 AM      1.67      0.00      1.67      0.00    138.67
Average:         4.80      0.00      4.80      0.00    137.60

#参数解释：  
  
tps：每秒磁盘的 I/O 传输总量  
rtps：每秒从磁盘读出的数据总量  
wtps：每秒向磁盘写入的数据总量  
bread/s：每秒从磁盘读出的数据量，单位为 块/s  
bwrtn/s：每秒向磁盘写入的数据量，单位为 块/s  
```

##### sar监测每一个块设备使用情况

```shell
sar -d 1 3
Linux 3.10.0-1160.el7.x86_64 (gitlab) 	11/18/2022 	_x86_64_	(4 CPU)

11:28:59 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
11:29:00 AM  dev253-0      9.00      0.00    112.00     12.44      0.01      2.44      1.44      1.30
11:29:00 AM dev253-16      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
11:29:00 AM  dev252-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

11:29:00 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
11:29:01 AM  dev253-0     20.00      0.00    512.00     25.60      0.00      0.75      0.05      0.10
11:29:01 AM dev253-16      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
11:29:01 AM  dev252-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

11:29:01 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
11:29:02 AM  dev253-0      9.00      0.00    112.00     12.44      0.00      0.11      0.00      0.00
11:29:02 AM dev253-16      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
11:29:02 AM  dev252-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

Average:          DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
Average:     dev253-0     12.67      0.00    245.33     19.37      0.00      1.00      0.37      0.47
Average:    dev253-16      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:     dev252-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
```





#### free

```bash
free -h
              total        used        free      shared  buff/cache   available
Mem:           7.6G        4.1G        2.6G        401M        980M        2.9G
Swap:            0B          0B          0B


输出简介

下面先解释一下输出的内容：
 Mem 行(第二行)是内存的使用情况。
 Swap 行(第三行)是交换空间的使用情况。
 total 列显示系统总的可用物理内存和交换空间大小。
 used 列显示已经被使用的物理内存和交换空间。
 free 列显示还有多少物理内存和交换空间可用使用。
 shared 列显示被共享使用的物理内存大小。
 buff/cache 列显示被 buffer 和 cache 使用的物理内存大小。
 available 列显示还可以被应用程序使用的物理内存大小。

我想只有在理解了一些基本概念之后，上面的输出才能帮助我们了解系统的内存状况。

buff/cache

先来提一个问题： buffer 和 cache 应该是两种类型的内存，但是 free 命令为什么会把它们放在一起呢？要回答这个问题需要我们做些准备工作。让我们先来搞清楚 buffer 与 cache 的含义。

buffer 在操作系统中指 buffer cache， 中文一般翻译为 “缓冲区”。要理解缓冲区，必须明确另外两个概念：”扇区” 和 “块”。扇区是设备的最小寻址单元，也叫 “硬扇区” 或 “设备块”。块是操作系统中文件系统的最小寻址单元，也叫 “文件块” 或 “I/O 块”。每个块包含一个或多个扇区，但大小不能超过一个页面，所以一个页可以容纳一个或多个内存中的块。当一个块被调入内存时，它要存储在一个缓冲区中。每个缓冲区与一个块对应，它相当于是磁盘块在内存中的表示(下图来自互联网)：


注意，buffer cache 只有块的概念而没有文件的概念，它只是把磁盘上的块直接搬到内存中而不关心块中究竟存放的是什么格式的文件。

cache 在操作系统中指 page cache，中文一般翻译为 “页高速缓存”。页高速缓存是内核实现的磁盘缓存。它主要用来减少对磁盘的 I/O 操作。具体地讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。页高速缓存缓存的是内存页面。缓存中的页来自对普通文件、块设备文件(这个指的就是 buffer cache 呀)和内存映射文件的读写。 

页高速缓存对普通文件的缓存我们可以这样理解：当内核要读一个文件(比如 /etc/hosts)时，它会先检查这个文件的数据是不是已经在页高速缓存中了。如果在，就放弃访问磁盘，直接从内存中读取。这个行为称为缓存命中。如果数据不在缓存中，就是未命中缓存，此时内核就要调度块 I/O 操作从磁盘去读取数据。然后内核将读来的数据放入页高速缓存中。这种缓存的目标是文件系统可以识别的文件(比如 /etc/hosts)。 

页高速缓存对块设备文件的缓存就是我们在前面介绍的 buffer cahce。因为独立的磁盘块通过缓冲区也被存入了页高速缓存(缓冲区最终是由页高速缓存来承载的)。

到这里我们应该搞清楚了：无论是缓冲区还是页高速缓存，它们的实现方式都是一样的。缓冲区只不过是一种概念上比较特殊的页高速缓存罢了。 

那么为什么 free 命令不直接称为 cache 而非要写成 buff/cache？ 这是因为缓冲区和页高速缓存的实现并非天生就是统一的。在 linux 内核 2.4 中才将它们统一。更早的内核中有两个独立的磁盘缓存：页高速缓存和缓冲区高速缓存。前者缓存页面，后者缓存缓冲区。当你知道了这些故事之后，输出中列的名称可能已经不再重要了。

free 与 available

在 free 命令的输出中，有一个 free 列，同时还有一个 available 列。这二者到底有何区别？ 

free 是真正尚未被使用的物理内存数量。至于 available 就比较有意思了，它是从应用程序的角度看到的可用内存数量。Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache。所以对于内核来说，buffer 和 cache 都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，available = free + buffer + cache。请注意，这只是一个很理想的计算方式，实际中的数据往往有较大的误差
```

##### 将buff/cache  内存释放 变成free内存

```bash
echo 1 > /proc/sys/vm/drop_caches
```



#### tracert

路由追踪



## sshd

#### 修改ssh默认端口号为24522

```bash
sed -i 's@#Port 22@Port 24522@' /etc/ssh/sshd_config
sed -i 's/ 22 / 24522 /' /etc/sysconfig/iptables

systemctl restart sshd.service iptables.service
systemctl stop firewalld && systemctl disable firewalld
```

#### 配置ssh免密码登录服务器

```bash
在自己电脑上使用git bash 使用命令
xsx@DESKTOP-GPD8SA9 MINGW64 /e/Desktop
$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/c/Users/xsx/.ssh/id_rsa):
Created directory '/c/Users/xsx/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /c/Users/xsx/.ssh/id_rsa.
Your public key has been saved in /c/Users/xsx/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:sTQi+vEbaTvfSNx081lHCKI+El2dSiprz8RASoPzMuU xsx@DESKTOP-GPD8SA9
The key's randomart image is:
+---[RSA 3072]----+
|   .      o...   |
|  o + .. o..o. . |
|   *.+o *o .  . .|
|  o.E.o=.+.    . |
|  .o. .=S . o   o|
|   . oo+o+ . o o.|
|    ..=+o .   o  |
|     ..=oo       |
|      ooo .      |
+----[SHA256]-----+

/c/Users/xsx/.ssh/id_rsa
/c/Users/xsx/.ssh/id_rsa.pub
#将id_rsa.pub. 放到服务器/root/.ssh/authorized_keys  这个时候再用我们的id_rsa 私钥就可以去远程连接服务器了
```

#### 配置ssh禁止使用密码登录服务器

```bash
sed -i 's/PasswordAuthentication yes/PasswordAuthentication no/g' /etc/ssh/sshd_config
systemctl stop sshd && systemctl start sshd
```

#### sshd_config 配置

```bash
ForwardAgent no
"ForwardAgent"设置连接是否经过验证代理（如果存在）转发给远程计算机。

ForwardX11 no
"ForwardX11"设置X11连接是否被自动重定向到安全的通道和显示集（DISPLAY set）。

RhostsAuthentication no
"RhostsAuthentication"设置是否使用基于rhosts的安全验证。

RhostsRSAAuthentication no
"RhostsRSAAuthentication"设置是否使用用RSA算法的基于rhosts的安全验证。

RSAAuthentication yes
"RSAAuthentication"设置是否使用RSA算法进行安全验证。

PasswordAuthentication yes
"PasswordAuthentication"设置是否使用口令验证。

FallBackToRsh no
“FallBackToRsh"设置如果用ssh连接出现错误是否自动使用rsh，由于rsh并不安全，所以此选项应当设置为"no”。

UseRsh no
“UseRsh"设置是否在这台计算机上使用"rlogin/rsh”，原因同上，设为"no"。

BatchMode no
“BatchMode”：批处理模式，一般设为"no"；如果设为"yes"，交互式输入口令的提示将被禁止，这个选项对脚本文件和批处理任务十分有用。

CheckHostIP yes
“CheckHostIP"设置ssh是否查看连接到服务器的主机的IP地址以防止DNS欺骗。建议设置为"yes”。

StrictHostKeyChecking no
“StrictHostKeyChecking"如果设为"yes”，ssh将不会自动把计算机的密匙加入"$HOME/.ssh/known_hosts"文件，且一旦计算机的密匙发生了变化，就拒绝连接。

IdentityFile ~/.ssh/identity
"IdentityFile"设置读取用户的RSA安全验证标识。

Port 22
"Port"设置连接到远程主机的端口，ssh默认端口为22。

Cipher blowfish
“Cipher”设置加密用的密钥，blowfish可以自己随意设置。

EscapeChar
“EscapeChar”设置escape字符
```

## shell 语法记录

#### 判断文件、目录是否存在等

**在linux shell中，可以利用if语句和“-e filename”表达式来判断文件是否存在，具体语法“if [-e filename]; then echo "文件存在"; else echo "文件不存在"; fi”。**

```shell
-e filename 如果 filename存在，则为真
-d filename 如果 filename为目录，则为真
-f filename 如果 filename为常规文件，则为真
-L filename 如果 filename为符号链接，则为真
-r filename 如果 filename可读，则为真
-w filename 如果 filename可写，则为真
-x filename 如果 filename可执行，则为真
-s filename 如果文件长度不为0，则为真
-h filename 如果文件是软链接，则为真
-z 用于判断一个变量或字符串长度是否为零

在Shell脚本中，要进行数字比较时，可以使用整数比较运算符来实现约等于的比较。常见的整数比较运算符有：
-eq：等于
-ne：不等于
-gt：大于
-lt：小于
-ge：大于等于
-le：小于等于
如果要进行数字约等于的比较，可以结合使用 -ge 和 -le 运算符，以指定范围进行判断。

以下是一个示例，展示了如何在Shell脚本中进行数字的约等于比较：

bash
#!/bin/bash

number=10

if [ $number -ge 8 ] && [ $number -le 12 ]; then
    echo "数字在 8 到 12 之间"
fi
```

**常用例子**

**如果存在某文件，则删除**

```shell
if [ -e trials ]; then rm ${result_path}trials; fi
```

**如果没有文件夹，则创建**

```shell
if [ ! -d $result_name ];then
   mkdir -p $result_name
fi
```





## shell 常用脚本

#### 检查IP能否ping通

```bash
#将123.58.2.0/24网络中可以ping通的偶数IP打印出来
for i in `seq 2 2 254` ; do ping -c 1 -w 1 -s 1 123.58.2.$i &>/dev/null && echo 123.58.2.$i ; done

for i in `cat ip.list` ; do ping -c 1 -w 1 -s 1 $i &>/dev/null && echo $i ok || echo $i no  ; done

ping.sh
# 打开输出文件
exec 6>ok_ip.txt
exec 7>no_ip.txt

for i in $(cat ip.list); do
    # 检查是否能 ping 通机器
    if ping -c1 -s1 -w1 "$i" &>/dev/null; then
        # 成功则输出到 ok_ip.txt
        echo "$i" >&6
    else
        # 失败则输出到 no_ip.txt
        echo "$i" >&7
    fi
done

echo -e "*********************************$(date)********************************************" >>no_ip.txt
echo "现在ping不通的IP如下:"
cat no_ip.txt 
# 关闭输出文件
exec 6>&-
exec 7>&-
```

#### 只对当前目录排序，并用直观的大小显示出来

```bash
for i in $(ls -l |grep '^d' |du -s *|sort -nr|awk '{print $2}');do du -sh $i;done

```

#### 报错：line 38: $'\r': command not found

这类问题通常是由于 Windows 下的换行符（CRLF，\r\n）与 Unix/Linux 下的换行符（LF，\n）的差异导致的。在Unix/Linux系统中，通常使用LF作为换行符，而在Windows系统中，使用CRLF。

使用如下的命令，替换windows换行符为linux格式下的换行符:

```bash
解决方案

sed -i 's/\r$//' your_script.sh
```





## date时间



#### 

```bash
#显示当前的时间
[root@5eb1r /]# date
Mon Jun 20 15:31:36 CST 2022

#显示三个月前时间
[root@5eb1r /]#  date  +%Y%m%d -d "+3 month ago"
20220320

#显示三个月后时间
[root@5eb1r /]#  date  +%Y%m%d -d "+3 month "
20220920

#显示三天前时间
[root@5eb1r /]#  date  +%Y%m%d -d "+3 day ago "
20220617

#显示三天后时间
[root@5eb1r /]#  date  +%Y%m%d -d "+3 day "
20220623

#n默认为1
[root@5eb1r /]#  date  +%Y%m%d -d "+n day "
20220621

```



## ls



#### ls按照时间排序查看

```bash

#升序排列是按照数据从低到高排列，降序排列是数据从高到低排列

ls按时间 降序 排列： ls -lt 
ls按时间 升序 排列：ls -lrt

ll -htr (最好用)
-h 单位显示更直观查看
sort -n  排序
uniq -c  去重
```



**检查当前路径目录日期是从 03:30 -- 03:40的目录文件总大小**

```shell
find -type f -newermt '2022-11-17 03:30:00' ! -newermt '2022-11-17 03:40:00' | xargs du -ch 
```

#### ls按照文件大小排序查看

```bash
# 降序
ls -Sl 

#升序
ls -Slr

du -xh --max-depth=1
```

#### 对当前目录和文件大小排序

```bash
du -s * |sort -nr
```

#### 只对当前目录排序，并用直观的大小显示出来

```bash
for i in $(ls -l |grep '^d' |du -s *|sort -nr|awk '{print $2}');do du -sh $i;done

```

#### 常用参数

```bash
 ls [-alrtAFR] [name...]
参数 :

-a 显示所有文件及目录 (. 开头的隐藏文件也会列出)
-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出
-r 将文件以相反次序显示(原定依英文字母次序)
-t 将文件依建立时间之先后次序列出
-A 同 -a ，但不列出 "." (目前目录) 及 ".." (父目录)
-F 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/"
-R 若目录下有文件，则以下之文件亦皆依序列出
```

## df 和du

#### df 查看 / 分区内容

```bash
df -hT |awk 'NR==1 || /\/$/'
```

#### du查看当前路径下每个文件占用空间的大小

```bash
du -xh --max-depth=1
du -xh --max-depth=1 | sort -hr

-x: 这个选项让 du 命令只遍历和当前目录在同一个文件系统中的文件和目录。这样可以防止 du 命令遍历到其他挂载的文件系统。
-h: 这个选项让 du 命令以人类可读的方式显示文件和目录的大小。例如，du 命令会使用 K，M，G 等单位，而不仅仅是字节数。
--max-depth=1: 这个选项设置 du 命令遍历目录的最大深度。在这个例子中，du 命令只会显示当前目录下一级的文件和目录的大小。
```

#### df和du查看结果不一致

```bash
sudo lsof | grep deleted

# 显示表头
sudo lsof | awk 'NR==1'

# 如果没有lsof 下载命令
yum install yum-utils  
yumdownloader --resolve lsof -y
--resolve: 这个选项让 yumdownloader 自动解析并下载所需要的依赖包
lsof : 这些是你想要下载的软件包的名称。
-y: 这个选项让 yumdownloader 在执行命令时不需要用户确认。
```

#### 解释话术

```bash
当你发现 df 显示磁盘满了，但 du 显示还有空间时，可能的原因有：正在被使用的文件被删除但未关闭，导致其占用的空间未被释放。
```



## 文件安装、卸载、解压缩

### rpm

**安装**

```shell
rpm -ivh xxx.rpm   (xxxx为软件包的名字)
```

**查询已安装的服务**

```shell
[root@hb3-test2 prometheus]#  rpm -qa |grep stress
stress-1.0.4-16.el7.x86_64
```

**卸载软件**

```
rpm -e xxx.rpm    (xxxx为软件包的名字)
rpm -qa |grep stress
stress-1.0.4-16.el7.x86_64

rpm -e --nodeps stress-1.0.4-16.el7.x86_64

		-e : 卸载   
		--nodeps : 忽略依赖
```

**升级软件的命令格式**

```shell
rpm -Uvh xxx.rpm
```

查询软件描述信息的命令格式

```shell
```







### tar

```shell
# 压缩
tar zcvf deploy.tar deploy

# 解压
tar zxvf deploy.tar


tar命令常用的参数

　　-z：使用gzip进行解压缩
　　-j：使用bzip2进行解压缩
　　-Z：使用compress进行解压缩
　　-v：显示解压缩执行过程
　　-f：指定要处理的文件名
```









## iptables防火墙

#### 卸载firewalld安装iptables

```bash
#关闭firewalld并禁止开机自启
systemctl stop firewalld && systemctl disable firewalld  

#  配置阿里云yum源，epel源
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo
wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
yum clean all
yum makecache fast

#列出所有已安装的软件包
yum list installed

#安装IPtables
yum install -y iptables-services
systemctl disable firewalld.service && systemctl stop firewalld.service
systemctl enable iptables.service && systemctl start iptables.service 
```



#### 根据默认规则进行优化

```bash
cat > /etc/sysconfig/iptables <<EOF
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 24522 -j ACCEPT
-A INPUT -j DROP
-A FORWARD -j DROP
COMMIT
EOF

#使修改的配置文件生效
systemctl reload iptables.service
```



#### 四表五链讲解

iptables具有Filter, NAT, Mangle, Raw四种内建表：

#####  1.Filter表

Filter表示iptables的默认表，因此如果你没有自定义表，那么就默认使用filter表，它具有以下三种内建链：

- **INPUT链** – 处理来自外部的数据。
- **OUTPUT链** – 处理向外发送的数据。
- **FORWARD链** – 将数据转发到本机的其他网卡设备上。

##### 2.NAT表

NAT表有三种内建链：

- **PREROUTING链** – 处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标IP地址（destination ip address），通常用于DNAT(destination NAT)。
- **POSTROUTING链** – 处理即将离开本机的数据包。它会转换数据包中的源IP地址（source ip address），通常用于SNAT（source NAT）。
- **OUTPUT链** – 处理本机产生的数据包。

##### **3. Mangle表**

Mangle表用于指定如何处理数据包。它能改变TCP头中的QoS位。Mangle表具有5个内建链：

- PREROUTING
- OUTPUT
- FORWARD
- INPUT
- POSTROUTING

##### **4. Raw表**

Raw表用于处理异常，它具有2个内建链：

- PREROUTING chain
- OUTPUT chain



#### 参数选项和规则语法

```bash
iptables(选项)(参数)

-t<表>：指定要操纵的表；
-A：向规则链中添加条目；
-D：从规则链中删除条目；
-i：向规则链中插入条目；
-R：替换规则链中的条目；
-L：显示规则链中已有的条目；
-F：清楚规则链中已有的条目；
-Z：清空规则链中的数据包计算器和字节计数器；
-N：创建新的用户自定义规则链；
-P：定义规则链中的默认目标；
-h：显示帮助信息；
-p：指定要匹配的数据包协议类型；
-s：指定要匹配的数据包源ip地址；
-j<目标>：指定要跳转的目标；
-i<网络接口>：指定数据包进入本机的网络接口；
-o<网络接口>：指定数据包要离开本机所使用的网络接口。


iptables -t 表名 <-A/I/D/R> 规则链名 [规则号] <-i/o 网卡名> -p 协议名 <-s 源IP/源子网> --sport 源端口 <-d 目标IP/目标子网> --dport 目标端口 -j 动作
```

##### 常用示例

###### **开放指定的端口**

```bash
iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT               #允许本地回环接口(即运行本机访问本机)
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT    #允许已建立的或相关连的通行
iptables -A OUTPUT -j ACCEPT         #允许所有本机向外的访问
iptables -A INPUT -p tcp --dport 22 -j ACCEPT    #允许访问22端口
iptables -A INPUT -p tcp --dport 80 -j ACCEPT    #允许访问80端口
iptables -A INPUT -p tcp --dport 21 -j ACCEPT    #允许ftp服务的21端口
iptables -A INPUT -p tcp --dport 20 -j ACCEPT    #允许FTP服务的20端口
iptables -A INPUT -j reject       #禁止其他未允许的规则访问
iptables -A FORWARD -j REJECT     #禁止其他未允许的规则访问
```

###### **屏蔽IP**

```
iptables -I INPUT -s 123.45.6.7 -j DROP       #屏蔽单个IP的命令
iptables -I INPUT -s 123.0.0.0/8 -j DROP      #封整个段即从123.0.0.1到123.255.255.254的命令
iptables -I INPUT -s 124.45.0.0/16 -j DROP    #封IP段即从123.45.0.1到123.45.255.254的命令
iptables -I INPUT -s 123.45.6.0/24 -j DROP    #封IP段即从123.45.6.1到123.45.6.254的命令是
```

###### **删除已添加的iptables规则**

```bash
#将所有iptables以序号标记显示，执行：
iptables -L -n --line-numbers

#比如要删除INPUT里序号为8的规则，执行：
iptables -D INPUT 8
```

## firewalld 基础使用

查看所有打开的端口

```bash
firewall-cmd --zone=public --list-ports
```

更新防火墙规则

```bash
firewall-cmd --reload
```

添加开放端口

```bash
firewall-cmd --zone=public --add-port=20010/tcp --permanent (permanent永久生效，没有此参数重启后失效)
```

查看端口是否开放

```bash
firewall-cmd --zone=public --query-port=20010/tcp
```

删除开放端口

```bash
firewall-cmd --zone=public --remove-port=20010/tcp --permanent
```

**注：每次更改firewall规则后需重新加载（firewall-cmd --reload）**



## IP地址分类

32位二进制数每八位为一组，用“.”分割 用十进制标识

![img](images/常用琐碎知识，复制粘贴方便/v2-b8095f9900a161438d6a9ef57fe8e049_720w.webp)

#### **A类地址**   

- 1.0.0.1-126.155.255.254   

  其中10.x.x.x 是私有地址，127.x.x.x 是保留地址，用作循环测试

#### **B类IP地址**  

- 范围从128.0.0.0 到 191.255.255.255 可用的B类网络有16382个
  172.16.0.0 ~ 172.31.255.255 是私有地址

#### **C类IP地址** 

- 范围从192.0.0.0 到 223.225.255.254
  192.168.x.x 是私有地址



#### 子网掩码

划分子网的，更准确的说，划分子网的同时，还能通过它知道主机在子网里面的具体ip的具体地址。

![什么是子网掩码？](images/常用琐碎知识，复制粘贴方便/v2-de0a8105723d9edc878bd7954fbf3bb7_720w.jpg)

###### 子网掩码作用



1. 方便管理，不同的子网可以相互隔离
2. 我们知道，IPv4的ip地址资源比较紧张，实际上整个互联网就是一个巨大的局域网，ip地址有限，那么通过划分子网，如何再在子网里面分配ip地址给子网的主机，这个时候同一一个ip就可以给一整个子网所共用，就解决了互联网ip不够的问题

###### 原理

既然要划分子网，要有一个规则，告诉路由器，IP的哪一部分是表示子网，哪一部分表示我在这个子网里面具体的地址

所以，实际上IP细来讲又分为三部分：网络部分（network）子网段部分(subnetwork)和主机部分(host)

一般大家喜欢把网络部分和子网部分合并成为网络地址(网络号)，把子网看做是网络的一部分，主机部分称为主机地址（主机号） 通俗理解：

- 网络号（subnetwork），表示我住哪个小区
- 主机号(host)，表示我家门牌号是多少

或者说网络号就是我们平时打电话的区号，主机号是你的电话号码，如010-80220110, 010是网络号，80220110是主机号

我们平常看到的192.168.0.x这样的IP，这是给我们看的地址，计算机内部计算把ip变成二进制，每一个IP被4个点分成4部分，每一部分有8位，也就是一个IP实际上是一个一共32位的二进制数

```text
如 192.168.0.3 换成二进制是 11000000 10101000 00000000 00000011
```

然后，这个32位的数根据需要被分为五大类分，由IANA([全球互联网地址指派机构](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%9C%B0%E5%9D%80%E6%8C%87%E6%B4%BE%E6%9C%BA%E6%9E%84))配给大家使用



###### 那么，是怎么样计算出来网络号和主机号的呢？

子网掩码会把一个IP地址按这个划分成这两部分，计算方法是通过把IP地址变成二进制，子网掩码也转成二进制后，两个二进制数按位做 **与运算。**

比如，一个C类地址，ip: 192.168.0.3 ，子网掩码是：255.255.255.0

1. 第一步先转而进制

```text
ip:   192.168.0.3   >  11000000 10101000 00000000 00000011
网掩码：255.255.255.0 >  11111111 11111111 11111111 00000000
```

2. 然后两个二进制按位做与计算

```text
11000000 10101000 00000000 00000011
&
11111111 11111111 11111111 00000000
=
11000000 10101000 00000000 00000000
```

3. 把这个而结果 : 11000000 10101000 00000000 00000000 每个8位转化回变成: 192.168.0.0

```text
192.168.0.0 这个就是我们的网络段（包括了上面说的网络部分和子网部分）
3 就是我们的主机号（主机在子网络里面的标识）
```

###### CIDR(无类别域间路由)/VLSM（可变长子网掩码）

上面这个算法看起来有点难理解，另外一种CIDR(无类别域间路由)/VLSM（可变长子网掩码）的表示法跟容易看懂，如下面这个:

```text
192.168.0.3/24
```

24表示这个ip的32位二进制数的前24位是网络标识的前缀，剩下的8位是主机标识，严格来，剩下的8位里面，全部是0是这个网络的标识，全部是1是这个网络的子网内广播地址，其他是这个子网网络的可用地址

```text
192.168.0.3   =>  11000000 10101000 00000000 00000011

网络标识的前缀： 11000000 10101000 00000000 --（前24位）换算位10进制：192.168.0
网络标识: 11000000 10101000 00000000 00000000 --剩下8位全是0，转10进制是：192.168.0.0
广播地址  11000000 10101000 00000000 11111111 --剩下8位全是1，转10进制是：192.168.0.255
```

大家看，这个就很容易理解了，除了网络标识和广播地址这两个特殊地址，剩下8位里面其他二进制数就是其他主机的标识。

实际上，这个192.168.0.3/24 ,前24位全1，就是等于255.255.255.0,这个就是这个网络的子网掩码，而无类别域间路由是基于**可变长子网掩码（VLSM）**来进行任意长度的前缀的分配的，所以这个24也可以变成其他数，如16

```text
192.168.0.3/16
```

只有前16位是网络，后面是地址16标识，换算回来就是

```text
192.168.0.0 是网络标识（后16位二进制全位0）
192.168.255.255这个是域内广播地址（后16位二进制全为1）
```

那么192.168.0.0 - 192.168.255.255 间所有的其他地址就是这个子网的可以容纳的主机地址

所以这个子网的地址数量明显比192.168.0.3/24那个要大多了

那么的子网掩码也很容易计算，就是前面16位全是1后面16位全是0，换算成10进制就是255.255.0.0

更多的CIDR/VLSM例子：



![img](images/常用琐碎知识，复制粘贴方便/v2-6767be87e0f4936e77224461038d9eec_720w-1668965071263-3.webp)

## 特殊符号用法



#### $?    $#   &   &&   **&>**  |   ||  ;  ;;



```bash
|
表示管道，上一条命令的输出，作为下一条命令参数，如：ls | grep “aa”，在ls的输出中查找aa字符串。

||
表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”

&
表示任务在后台执行，执行程序的后面添加&，这样在程序执行时我们仍然可以操作控制台。如要在后台运行test.jar,则可以用  java -jar test.jar > log.txt &

&&
表示前一条命令执行成功时，才执行后一条命令 ，如 echo '1‘ && echo ‘2’

$?和$#
$?是执行上一条指令的返回值；$#是调用shell脚本传递的参数个数

&>
可以将错误信息或者普通信息都重定向输出

; 分号 
在 shell 中，担任"连续指令"功能的符号就是"分号"。譬如以下的例子：cd ~/backup ; mkdir startup ;cp ~/.* startup/.

;; 连续分号
专用在 case 的选项，担任 Terminator 的角色。
case "$fop" inhelp) echo "Usage: Command -help -version filename";;version) echo "version 0.1" ;;esac

[   ] 中括号
常出现在流程控制中，扮演括住判断式的作用。if [ "$?" != 0 ]thenecho "Executes error"exit1fi
这个符号在正则表达式中担任类似 "范围" 或 "集合" 的角色
rm -r 200[1234]

[[     ]]
这组符号与先前的 [] 符号，基本上作用相同，但她允许在其中直接使用 || 与&& 逻辑等符号。
#!/bin/bashread akif [[ $ak > 5 || $ak< 9 ]]thenecho $akfi

, 逗点 (comma，标点中的逗号)
这个符号常运用在运算当中当做"区隔"用途。如下例
#!/bin/bashlet "t1 = ((a = 5 + 3, b = 7 - 1, c = 15 / 3))"echo "t1= $t1, a = $a, b = $b"

'string' 单引号 
被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量替换。
heyyou=homeecho '$heyyou' # We get $heyyou

"string" 双引号 
被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。
heyyou=homeecho "$heyyou" # We get home

` 倒引号 
在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。
fdv=`date +%F`echo "Today $fdv"
在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。
```

## linux标准输入输出

```shell
linux中有三种标准输入输出，分别是STDIN，STDOUT，STDERR，对应的数字是0，1，2。

STDIN是标准输入，默认从键盘读取信息；
STDOUT是标准输出，默认将输出结果输出至终端；
STDERR是标准错误，默认将输出结果输出至终端。

由于STDOUT与STDERR都会默认显示在终端上，为了区分，就有了编号的0，1，2的定义，用1表示STDOUT，2表示STDERR。

2>&1，指将标准输出、标准错误指定为同一输出路径
若要将所有标准输出及标准错误都输出至文件，可用&表示全部1和2的信息，eg：
find /etc -name passwd &>find.all 或 find /etc -name passwd >find.all 2>&1

`2>&1 >/dev/null` 和 `2 &> /dev/null` 都是用于重定向命令的标准错误和标准输出的表达式，但它们在不同的 shell 环境中可能有不同的效果。
1. `2>&1 >/dev/null`：这个表达式在大多数 shell（如 Bash, Zsh, Dash）中都能正常工作。它的意思是将标准错误（文件描述符 2）重定向到标准输出（文件描述符 1），然后将标准输出重定向到 `/dev/null`。
my_command 2>&1 >/dev/null
这将执行 `my_command`，并将其标准错误和标准输出都重定向到 `/dev/null`。这意味着您不会在终端中看到任何来自 `my_command` 的输出信息。

2. `2 &> /dev/null`：这个表达式在 Bash shell 中表示将命令的标准错误和标准输出都重定向到 `/dev/null`。在其他 shell（如 Dash）中，这个表达式可能不会按预期工作。
my_command 2 &> /dev/null
这将执行 `my_command`，并将其标准错误和标准输出都重定向到 `/dev/null`。这意味着您不会在终端中看到任何来自 `my_command` 的输出信息。

总结：虽然 `2>&1 >/dev/null` 和 `2 &> /dev/null` 都可以实现相同的目的，但它们在不同的 shell 环境中可能有不同的效果。为了确保兼容性，建议使用 `2>&1 >/dev/null`。
```





## nmap

#### 快速ping多个网段

```bash
nmap  -sn 101.36.178.0/24 101.36.172.0/24    快速ping多个网段，12个网段15秒结束
```

#### 检测某个IP的端口开放了那些

```bash
nmap -Pn 22,80,3306,443, x.x.x.x
```



## 常用快捷键

```bash
xshell终端中
ctrl w     #删除上个单词
ctrl ins   #复制
shift ins	   #粘贴
alt 1 2 3  #快速切换终端
yyp			#复制本行粘贴
ctrl v 	    #选中   y 复制   p粘贴


ctrl c	   #复制
ctrl v     #粘贴
ctrl a    全选
ctrl pageup   #上一个浏览器页面
ctrl pagedown   #下一个
ctrl w 		#关闭当前浏览器
ctrl tab	#切换至下个浏览器页面
ctrl shift tab	#切换至上个浏览器
ctrl 1 2 3	#快速切换浏览器页面
```

## 查看当前开放的端口和进程



#### 查看端口

```bash
ss -tuna 
netstat -utplna
```

#### 查看进程

```bash
[root@test ~]# ps -ef 
```

####  查看进程的父进程 

```bash
yum -y install psmisc
pstree -aps  异常进程ID号
```



## OSI七层结构

![img](images/常用琐碎知识，复制粘贴方便/765400-20190312111848255-75322857.png)

#### TCP/IP 五层协议

###### 应用层：

```shell
应用程序/原始数据
1、数据采集出来
```

###### 表示层：

```shell
定义格式/压缩/加密    快速传递、安全传递、鸡毛信
1、添加标记
```

###### 会话层：

```shell
会话/全双工/半双工		 电话/对讲机  工作模式
1、添加身份信息
```

######  传输层：

```shell
分段/重组/端口     
1.分段提升了传输效率，如果一个1G数据，传输过程中出现了错误，那么重新传输又需要1G，可以分割从成10个100M，如果某一个分段出现了问题，重新传输失败的段即可，最后在终点进行重组

确保数据准确性
```

###### 网络层：

```shell
IP地址/寻址/路由
1、`分割广播域，连接不同的网络，需要进行寻址`便于寻址网络层会给数据增加一个IP地址，用于寻址和增加路由
总目标，全球地址

IP地址：`32位二进制数每八位为一组，用“.”分割 用十进制标识、进制转换、分类、私有地址、子网掩码、网络地址`
网络层封装：将数据包转换为数据段，去掉IP头部交给传输层
包封装：将数据段转为数据包，交给数据链路层。
路由器工作原理：路由器的路由表是记网段地址，"路由器用于跨越网段通信，交换机是局域网" 路由器就是网络的边界，既隔离又转发
当一个数据包被路由器所接收时，路由器检查数据的IP地址，并判断这个数据包是用于它自己的网络还是其它网络。如果路由器判断这个数据包是用于它自己，它就会接收；如果不是用于它自己，这个数据包就会被拒绝。
```

###### 数据链路层：

```shell
MAC地址/局域网/
1、分段目标，局部地址、邮递员   局域网地址
邮递员送到邮局就相当于数据链路层的工作 之后交给网络层来送快递

MTU是Maximum Transmission Unit 的缩写，中文翻译为 最大传输单元，是指能通过的最大数据包大小（以字节为单位）而MTU指定了网络中可传输数据包的最大尺寸，在我们常用的以太网中，MTU是1500字节。超过此大小的数据包就会将多余的部分拆分再单独传输。就像货车通过限高的桥洞一样，货物高度超过限制高度了，就需要卸下一些货物，分两批通过限高路段。

数据链路层：功能、地址、帧封装、组件局域网、VLAN、TRUNK。
代表设备：交换机，交换机工作的原理：`学习、广播、转发、更新`通过MAC地址寻址进行局域网通信。	
交换机的接口有两种工作模式，一种lacces访问模式某个vlan（连接计算机使用的），一种trunk模式承载多个VLAN（连接交换机使用的）	
数据链路层封装：将数据包转换为数据帧，并添加MAC头，帧封装
```

###### 物理层：

```shell
传输介质/比特流 
1、 电流/光/无线信号/4G/5G/  传输最底层的介质
采用某种介质进行传输比特流，计算机语言就是0和1.

`物理层关心的是电器特性，功能特性`
```

#### 解释

```
TCP/IP参考模型：

应用层：应用层负责处理应用程序之间的通信。在这一层，数据被称为报文（Message）。
传输层：传输层负责提供端到端的可靠数据传输。数据在传输层被封装为数据段（Segment）。
网际层（互联网层）：网际层负责数据在网络中的路由和转发。数据在网际层被封装为IP数据包（Packet）。
网络接口层（数据链路层）：网络接口层负责在相邻节点之间可靠地传输数据。数据在网络接口层被封装为数据帧（Frame）。
```



###### 二进制快速转换方法

```shell
二进制快速学习方法  生活中所用到的就是0~255 最大数值

128		64		32		16		8		4		2		1
1		1		1		1		1		1		1		1
---------------------------------------------------------------
								1		1		0		1
0		1		1		1		1		1		0		0
1		1		0		0		0		0		0		0	192转为2进制
1		0		1		0		1		0		0		0	168转为2进制
1		1		1		1		1		1		1		0	254转为2进制
1
二进制与十进制转换，先转换最大的数

比如将13、129、124转换为2进制 
13	=	1000+100+1=1101
129	=	10000001
124	=	01111100
124-64=60
60-32=28
28-16=12
12-8=4
4-4=0
常见的192、168、254
192					168					254
192-128=64			168-128=40			254-128=126
64-64=0				40-32=8				126-64=62
					8-8=0				62-32=30
										30-16=14
										14-8=6
										6-4=2
										2-2=0
```



#### 网桥（Bridge）

###### 什么是网桥？

![什么是网桥？网桥有哪些优缺点？](images/常用琐碎知识，复制粘贴方便/v2-5b3b1d6aa9c0db40876b73d9e1eb158a_720w-1668962835781-7.jpg)

**网桥（Bridge）是早期的两端口二层网络设备，用来连接不同网段。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。网桥比集线器（Hub）性能更好，集线器上各端口都是共享同一条背板总线的。后来，网桥被具有更多端口、同时也可隔离冲突域的交换机（Switch）所取代。**

**网桥（Bridge）像一个聪明的中继器。中继器从一个网络电缆里接收信号，放大它们，将其送入下一个电缆。相比较而言，网桥对从关卡上传下来的信息更敏锐一些。网桥是一种对帧进行转发的技术，根据MAC分区块，可隔离碰撞。网桥将网络的多个网段在数据链路层连接起来。**

![img](images/常用琐碎知识，复制粘贴方便/v2-2085bb19527460bc9acc05f97340451f_720w.webp)



网桥也叫桥接器，是连接两个局域网的一种存储/转发设备，它能将一个大的LAN分割为多个网段，或将两个以上的LAN互联为一个逻辑LAN，使LAN上的所有用户都可访问服务器。扩展局域网最常见的方法是使用网桥。最简单的网桥有两个端口，复杂些的网桥可以有更多的端口。网桥的每个端口与一个网段相连。

###### 网桥优点

1、过滤通信量。网桥可以使用局域网的一个网段上各工作站之间的信息量局限在本网段的范围内，而不会经过网桥溜到其他网段去。
2、扩大了物理范围，也增加了整个局域网上的工作站的最大数目。
3、可使用不同的物理层，可互连不同的局域网。
4、提高了可靠性。如果把较大的局域网分割成若干较小的局域网，并且每个小的局域网内部的信息量明显地高于网间的信息量，那么整个互连网络的性能就变得更好。

###### 网桥缺点

1、由于网桥对接收的帧要先存储和查找站表，然后转发，这就增加了时延。
2、在MAC子层并没有流量控制功能。当网络上负荷很重时，可能因网桥缓冲区的存储空间不够而发生溢出，以致产生帧丢失的现象。
3、具有不同MAC子层的网段桥接在一起时，网桥在转发一个帧之前，必须修改帧的某些字段的内容，以适合另一个MAC子层的要求，增加时延。
4、网桥只适合于用户数不太多（不超过几百个）和信息量不太大的局域网，否则有时会产生较大的广播风暴。

## dmidecode 命令解释"内存"



dmidecode 可以查询 BIOS、系统、主板、处理器、内存、缓存等非常重要信息，下面介绍一下常用命令

```shell
[root@demo ~]# dmidecode -t1
# dmidecode 3.0
Getting SMBIOS data from sysfs.
SMBIOS 2.7 present.

Handle 0x0100, DMI type 1, 27 bytes
System Information
	Manufacturer: Dell Inc.
	Product Name: PowerEdge R720			# 服务器型号
	Version: Not Specified
	Serial Number: 7GTKD92					# 主板的序列号，也称SN号
	UUID: 4C4C4544-0047-5410-804B-B7C04F443932
	Wake-up Type: Power Switch
	SKU Number: SKU=NotProvided;ModelName=PowerEdge R720
	Family: Not Specified
```

**服务器序列号（SN）号**

```shell
dmidecode -s system-serial-number 
```

**最大支持存容量**

```
[root@demo ~]# dmidecode | grep "Maximum Capacity" |sed  "s/^[ \t]*//" 
Maximum Capacity: 1536 GB
```

**查看插槽上内存的速率,没插就是unknown。**

```shell
[root@storage114 ~]# dmidecode|grep -A16 "Memory Device"|grep 'Speed'
	Speed: 1333 MHz
	Speed: 1333 MHz
	Speed: 1333 MHz
	Speed: 1333 MHz
	Speed: Unknown
	Speed: Unknown
	Speed: Unknown
	Speed: Unknown
	Speed: Unknown
	Speed: Unknown
	Speed: Unknown
	Speed: Unknown
	Speed: 1333 MHz
	Speed: 1333 MHz
	Speed: 1333 MHz
	Speed: 1333 MHz
	Speed: Unknown
	Speed: Unknown
	Speed: Unknown
	Speed: Unknown
	Speed: Unknown
	Speed: Unknown
	Speed: Unknown
	Speed: Unknown
```



**查看内存信息**

```
[root@demo ~]#  dmidecode -t memory  
# dmidecode 3.0
Getting SMBIOS data from sysfs.
SMBIOS 2.7 present.

Handle 0x1000, DMI type 16, 23 bytes
Physical Memory Array
	Location: System Board Or Motherboard
	Use: System Memory
	Error Correction Type: Multi-bit ECC
	Maximum Capacity: 1536 GB
	Error Information Handle: Not Provided
	Number Of Devices: 24

Handle 0x1100, DMI type 17, 34 bytes
Memory Device
	Array Handle: 0x1000
	Error Information Handle: Not Provided
	Total Width: 72 bits
	Data Width: 64 bits
	Size: 16384 MB
	Form Factor: DIMM
	Set: 1
	Locator: DIMM_A1 
	Bank Locator: Not Specified
	Type: DDR3
	Type Detail: Synchronous Registered (Buffered)
	Speed: 1600 MHz
	Manufacturer: 00CE04B300CE
	Serial Number: 12AD8057
	Asset Tag: 03143021
	Part Number: M393B2G70QH0-YK0  
	Rank: 2
	Configured Clock Speed: 1600 MHz				# 内存的速度

Handle 0x1101, DMI type 17, 34 bytes
Memory Device
	Array Handle: 0x1000
	Error Information Handle: Not Provided
	Total Width: 72 bits
	Data Width: 64 bits
	Size: 16384 MB
	Form Factor: DIMM
	Set: 1
	Locator: DIMM_A2 
	Bank Locator: Not Specified
	Type: DDR3
	Type Detail: Synchronous Registered (Buffered)
	Speed: 1600 MHz
	Manufacturer: 00CE04B300CE
	Serial Number: 12AD8057
	Asset Tag: 03143021
	Part Number: M393B2G70QH0-YK0  
	Rank: 2
	Configured Clock Speed: 1600 MHz

Handle 0x1102, DMI type 17, 34 bytes
Memory Device
	Array Handle: 0x1000
	Error Information Handle: Not Provided
	Total Width: 72 bits
	Data Width: 64 bits
	Size: 16384 MB
	Form Factor: DIMM
	Set: 1
	Locator: DIMM_A3 
	Bank Locator: Not Specified
	Type: DDR3
	Type Detail: Synchronous Registered (Buffered)
	Speed: 1600 MHz
	Manufacturer: 00CE04B300CE
	Serial Number: 12AD8057
	Asset Tag: 03143021
	Part Number: M393B2G70QH0-YK0  
	Rank: 2
	Configured Clock Speed: 1600 MHz

Handle 0x1103, DMI type 17, 34 bytes
Memory Device
	Array Handle: 0x1000
	Error Information Handle: Not Provided
	Total Width: 72 bits
	Data Width: 64 bits
	Size: 16384 MB
	Form Factor: DIMM
	Set: 1
	Locator: DIMM_A4 
	Bank Locator: Not Specified
	Type: DDR3
	Type Detail: Synchronous Registered (Buffered)
	Speed: 1600 MHz
	Manufacturer: 00CE04B300CE
	Serial Number: 12AD8057
	Asset Tag: 03143021
	Part Number: M393B2G70QH0-YK0  
	Rank: 2
	Configured Clock Speed: 1600 MHz

[root@storage117 ~]# dmidecode | grep -A16 "Memory Device" | grep "Size" 
	Size: 16384 MB
	Size: 16384 MB
	Size: 16384 MB
	Size: 16384 MB
	Size: No Module Installed
	Size: No Module Installed
	Size: No Module Installed
	Size: No Module Installed
	Size: No Module Installed
	Size: No Module Installed
	Size: No Module Installed
	Size: No Module Installed
	Size: 16384 MB
	Size: 16384 MB
	Size: 16384 MB
	Size: 16384 MB
	Size: No Module Installed
	Size: No Module Installed
	Size: No Module Installed
	Size: No Module Installed
	Size: No Module Installed
	Size: No Module Installed
	Size: No Module Installed
	Size: No Module Installed

```



## 磁盘管理

###  DD磁盘测速

```shell
[root@gitlab ]# dd if=/dev/zero of=/tmp/test1.img bs=1G count=1 oflag=dsync
1+0 records in
1+0 records out
1073741824 bytes (1.1 GB) copied, 3.61284 s, 297 MB/s

写入一个G的数据，可以发现，服务器的吞吐率是297 MB/s，这其中
if=/dev/zero (if=/dev/input.file) ：用来设置dd命令读取的输入文件名。
of=/tmp/test1.img (of=/path/to/output.file)：dd命令将input.file写入的输出文件的名字。
bs=1G (bs=block-size) ：设置dd命令读取的块的大小。例子中为1个G。
count=1 (count=number-of-blocks)：dd命令读取的块的个数。
oflag=dsync (oflag=dsync) ：使用同步I/O。不要省略这个选项。这个选项能够帮助你去除caching的影响，以便呈现给你精准的结果。
conv=fdatasyn: 这个选项和oflag=dsync含义一样。
```



### 磁盘格式化挂载

**查看磁盘信息**

```bash
lsblk   
########查看磁盘信息
[root@openvpn /]# lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
vda    253:0    0   50G  0 disk 
└─vda1 253:1    0   50G  0 part /
vdb    253:16   0  100G  0 disk 
```

**将未挂载的vdb磁盘进行分区挂载**

```bash
[root@openvpn ~]# fdisk /dev/vdb 
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.


Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-209715199, default 2048): 2048
Last sector, +sectors or +size{K,M,G} (2048-209715199, default 209715199): 
Using default value 209715199
Partition 1 of type Linux and of size 100 GiB is set

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
```

**格式化磁盘挂载**

```bash

#######格式化磁盘
[root@openvpn ~]# mkfs -t ext4 /dev/vdb1
NAME   FSTYPE LABEL UUID                                 MOUNTPOINT
vda                                                      
└─vda1 ext4         9f64194b-530f-4d17-bef9-d3607ecb5d55 /
vdb                                                      
└─vdb1 ext4         2ffae3ec-11d0-40d7-81fb-f078a4f082f6 


#######临时挂载
[root@openvpn ~]#mount /dev/vdb1 /opt/

[root@openvpn ~]# lsblk -f
NAME   FSTYPE LABEL UUID                                 MOUNTPOINT
vda                                                      
└─vda1 ext4         9f64194b-530f-4d17-bef9-d3607ecb5d55 /
vdb                                                      
└─vdb1 ext4         2ffae3ec-11d0-40d7-81fb-f078a4f082f6 /var



blkid 



#设置永久挂载不失效
[root@openvpn ~]# vim /etc/fstab
UUID=9f64194b-530f-4d17-bef9-d3607ecb5d55 /                       ext4    defaults        1 1
UUID=2ffae3ec-11d0-40d7-81fb-f078a4f082f6 /var                    ext3    defaults        1 1

[root@openvpn ~]#mount -a
```

**删除磁盘分区**

```bash
[root@openvpn ~]# lsblk -a
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
vda    253:0    0   50G  0 disk 
└─vda1 253:1    0   50G  0 part /
vdb    253:16   0  100G  0 disk 
└─vdb1 253:17   0  512B  0 part 
[root@openvpn ~]# fdisk /dev/vdb
Welcome to fdisk (util-linux 2.23.2).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): d          ##d 为删除
Selected partition 1			##输入要删除的分区号
Partition 1 is deleted
Command (m for help): w			## 保存并退出
The partition table has been altered!
Calling ioctl() to re-read partition table.
Syncing disks.
```



### LVM磁盘管理

#### 挂载新增的磁盘操作

**创建物理卷（Physical Volume）**

```bash
#将物理磁盘/dev/sdd初始化为物理卷，这是创建LVM的第一步
pvcreate /dev/sdd
```

**创建卷组（Volume Group）**

```bash
#创建一个名为data1vg的卷组，包含之前创建的物理卷/dev/sdd。卷组是一种将多个物理卷组合在一起，使其看起来像一个大的存储池的方法。
vgcreate data1vg /dev/sdd

# 多个
vgcreate data1vg /dev/sdd vgcreate data1vg /dev/sdd

# 也可以将多个物理卷设置为一个卷组
vgcreate data1vg /dev/sdd /dev/sde /dev/sdf
```

**创建逻辑卷并指定大小（Logical Volume）**

```bash
#在data1vg卷组中创建一个名为data1lv的逻辑卷，并设置其大小为100GB。逻辑卷可以被看作是在卷组上的分区，它可以根据需要进行大小调整和移动。
lvcreate -L 100G -n data1lv data1vg

#或者使用
lvcreate -l 100%FREE -n datalv datavg
```

**格式化逻辑卷文件系统**

```bash
1、#在/dev/data1vg/data1lv逻辑卷上创建XFS文件系统。
mkfs.xfs /dev/data1vg/data1lv

2、#在/dev/data1vg/data1lv逻辑卷上创建ext4文件系统。
mkfs.ext4 /dev/data1vg/data1lv
```

**创建一个新目录用于挂载逻辑卷**

```bash
mkdir data1
# 临时挂载
mount /dev/data1vg/data1lv /data1
# 永久挂载
echo '/dev/data1vg/data1lv /data1 xfs defaults 0 0' | sudo tee -a /etc/fstab

#### /dev/data1vg/data1lv是要挂载的设备
#### /data1是挂载点
#### xfs是文件系统类型
#### defaults表示使用默认挂载选项
#### 最后的两个0分别表示dump备份的开关（通常为0）和文件系统检查的顺序（根文件系统为1，其他文件系统为2，0表示不检查)
```

---

#### 卷组扩缩容磁盘空间

**扩容**

```bash
# 将/dev/sdg和/dev/sdh添加到data1vg卷组中，从而扩大该卷组的容量,可一次添加一个也可一次添加多个。  extend(延申)
vgextend data1vg /dev/sdg

vgextend data1vg /dev/sdg /dev/sde /dev/sdf
```

**缩容**

```bash
# 如果要移除的物理卷还在被挂载中，请先备份并取消挂载，避免数据丢失
umount /data2

#可以使用pvmove命令将物理卷上的数据移动（迁移到其他物理卷上）。例如，如果要将/dev/sde的数据移动到/dev/sdg和/dev/sdf上
pvmove /dev/sde /dev/sdf /dev/sdg

# 从data1vg卷组中删除/dev/sde
vgreduce data1vg /dev/sde
```

#### 逻辑卷扩缩容

```bash
# 扩展逻辑卷的大小 ，命令格式
lvextend -L +[大小] /dev/[卷组名]/[逻辑卷名]
#### -L 参数表示你想要设定的逻辑卷的大小。你需要在大小前面加上 + 符号，表示你想要增加的大小。

# 给名为datalv增加50G空间
lvextend -L +50G /dev/data1vg/data1lv
```

在扩展了逻辑卷的大小之后，还需要对文件系统扩展以使用新增的空间，如果是XFS文件系统，使用 xfs_growfs,如果是ext4 文件系统，使用resize2fs命令

```bash
xfs_growfs /dev/data1vg/data1lv
resize2fs /dev/data1vg/data1lv
```

#### 使用卷组新的逻辑卷

可以使用lvcreate命令在现有的卷组中创建新的逻辑卷。以下是命令的一般形式

```bash
lvcreate -L [大小] -n [逻辑卷名] [卷组名]

####  -L 参数表示你想要设定的逻辑卷的大小
####  -n 参数后面是你想要设定的逻辑卷的名称
```

例如，如果你想要在 data1vg 卷组中创建一个大小为 50GB，名为 data2lv 的逻辑卷，你可以使用以下命令：

```bash
lvcreate -L 50G -n data2lv data1vg
```

创建新的逻辑卷之后，你需要在上面创建文件系统，然后才能使用。如果你想要创建 XFS 文件系统，你可以使用 `mkfs.xfs` 命令：

```bash
mkfs.xfs /dev/data1vg/data2lv
```

挂载

```bash
mkdir /data2
mount /dev/data1vg/data2lv /data2
echo '/dev/data1vg/data2lv /data2 xfs defaults 0 0' | sudo tee -a /etc/fstab
```

---

### lsscsi 命令语法：

```shell
lsscsi [选项] [H:C:T:L]
lsscsi 命令选项：

选项	含义
-g	显示SCSI通用设备文件名称
-k	显示内核名称而不是设备节点名
-d	显示设备节点的主要号码和次要号码
-H	列出当前连接到系统的SCSI主机而不是SCSI设备
-l	显示每一个SCSI设备（主机）的附加信息
-c	相对于执行 cat /proc/scsi/scsi 命令的输出
-p	显示额外的数据完整性（保护）的信息
-t	显示传输信息
-L	以“属性名=值”的方式显示附加信息
-v	当信息找到时输出目录名
-y<路径>	假设sysfs挂载在指定路径而不是默认的 “/sys”
-s	显示容量大小。
-c	用全称显示默认的信息。
-d	显示设备主，次设备号。
-g	显示对应的sg设备名。
-H	显示主机控制器列表，-Hl,-Hlv。
-l	显示相关属性，-ll,-lll=-L。
-v	显示设备属性所在目录。
-x	以16进制显示lun号。
-p	输出DIF,DIX 保护类型。
-P	输出有效的保护模式信息。
-i	显示udev相关的属性
-w	显示WWN
-t	显示相应传输信息(ATA,FC,SBP,ISCSI,SPI,SAS,SATA,USB)，-Ht,-tl.（包括sas地址）
```

```shell
[root@controller1 ~]# lsscsi 
[0:2:0:0]    	 disk    DELL     PERC H710        3.13  /dev/sda 
[0:2:1:0]    	 disk    DELL     PERC H710        3.13  /dev/sdb 
[0:2:2:0]   	 disk    DELL     PERC H710        3.13  /dev/sdc 
[0:2:3:0]   	 disk    DELL     PERC H710        3.13  /dev/sdd 
[5:0:0:0]    	cd/dvd   PLDS     DVD+-RW DS-8ABSH LD51  /dev/sr0 
ID:              设备类型   设备厂商    型号            版本信息    设备主节点
host,channel,id,  

[root@controller1 ~]# lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0  1.8T  0 disk 
├─sda1            8:1    0    2M  0 part 
├─sda2            8:2    0    1G  0 part /boot
└─sda3            8:3    0  1.8T  0 part 
  └─centos-root 253:0    0  1.8T  0 lvm  /
sdb               8:16   0  5.5T  0 disk 
sdc               8:32   0  5.5T  0 disk 
└─sdc1            8:33   0  5.5T  0 part /srv/node/d0
sdd               8:48   0  5.5T  0 disk 
└─sdd1            8:49   0  5.5T  0 part /srv/node/d1
sr0              11:0    1 1024M  0 rom
```



### 设置Swap分区开启方法

**使用 `dd` 命令创建新的 Swap 文件：**

```shell
sudo dd if=/dev/zero of=/swapfile bs=1M count=8192
```

**设置正确的文件权限：**

```shell
sudo chmod 600 /swapfile
```

**将文件设置为 Swap 分区：**

```
sudo mkswap /swapfile
```

**启用 Swap 分区：**

```shell
sudo swapon /swapfile
```



## 服务器正在运行的用户

#### 查看目前正在登录的用户

```bash
查看自己登录的终端信息
[root@test ~]# w |grep 'w$'

查看目前登录的用户IP
[root@test ~]# w |awk 'NR>=3 {print $3}'
124.127.244.29
124.127.244.29
```

#### 查看自己登录身份

```bash
[root@test ~]# whoami
root
```



## bond 

Bond技术即bonding，它是Linux Kernel的一个模块，能将多块物理网卡绑定到一块虚拟网卡上，并通过修改网口驱动让多块网卡看起来是一个单独的以太网接口设备（对外只有一个IP），一般用于解决网卡的单点故障或网卡负载较高的场景。



#### **Bond技术原理**

Bond技术需要物理网卡开启混杂模式才能正常工作。在混杂模式下，网卡不只接收目的MAC地址为自身的以太网帧，而是接收网络上所有的数据帧。为了实现多块网卡的协同工作，Bond将自己的MAC地址复制到各个物理网卡上，让所有的网卡共享同一个MAC地址。这个方式就要求所有的网卡都要支持BIOS，这样才能够让操作系统将MAC地址写到网卡上。

对于单物理网卡的Bond网卡来说，Bond网卡的MAC地址和物理网卡的物理地址是一致的。而对于多物理网卡的Bond网卡而言，其中一块物理网卡会被设置为 Master，其他的网卡则都是Slave，Bond网卡的MAC地址取自标志为Master的物理网卡，然后再将这个MAC地址复制到其他物理网卡上。所以在安装网卡时，我们需要指定Bond网卡，以及Bond网卡所对应的标志为Master的物理网卡。

bond:可以理解为就是双网卡或者更多网卡绑定，逻辑上当作一个网卡用。

#### **网卡Bond模式**

网卡Bond模式总共有7种，最常用的是负载模式（模式0）和主备模式（模式1），在网络流量较大的场景下推荐使用负载模式，而在可靠性要求较高的场景下则推荐使用主备模式。接下来将对这7种模式进行简单的介绍以及优缺点对比。

```shell
1）mode=0
# 介绍
(balance-rr)Round-robin policy（平衡抡循环策略）
        特点：传输数据包顺序是依次传输（即：第1个包走eth0，下一个包就走eth1….一直循环下去，直到最后一个传输完毕）
        问题：一个连接的数据包从不同的接口发出的话，中途再经过不同的链路，在客户端很有可能会出现数据包无序到达的问题，而无序到达的数据包需要重新要求被发

2）mode=1
# 介绍
bond1为主备模式，只有一个网卡在使用中。而且仅当活动网卡失效时才会激活其他的网卡。这种模式下做bond的两张或多张网卡的MAC地址和Bond虚拟网卡的MAC地址相同，而Bond的MAC地址是Bond创建启动后活动网卡的MAC地址这种模式要求主被网卡能快速的切换，即当主网卡出现故障后能迅速地切换至备用网卡。切换过程中，上层的应用几乎不受影响，因为Bond的驱动程序会临时接管上层应用的数据包，存放至数据缓冲区，等待备用网卡启动后再发送出去。但是如果切换时间过长，则会引起缓冲区的溢出，导致丢包
        优点就是很安全，两块网卡同时坏的概率很低。
        缺点则是利用率低下，只有50%的利用率。

应用场景一般是服务器的管理口，管理口一般没有太高的网络需求，稳定第一

mode=2
平衡策略 balance-xor（XOR policy）

基于特性的 Hash 算法传输数据包。
缺省的策略为：(源MAC地址 XOR 目标MAC地址) % slave数量。 # XRO为异或运算，值不同时结果为1，相同为0
可以通过xmit_hash_policy选项设置传输策略。
       特点：提供负载均衡和容错能力。


3）mode=4
# 介绍        
       bond4为链路聚合模式。相当于两块小网卡合并一起当作一个大网卡用，类似1+1=2
        前置条件1：交换机需要支持IEEE802.3ad(链路聚合标准)，并且在交换机上进行相应配置。
        前置条件2：ethtool支持获取每个slave的速率和双工设定

应用场景一般是业务网了，需要的大的带宽的情况比较适合
```



```shell
cat /proc/net/bonding/bond1
```




## awk 常用语法

```bash
多个分隔符# awk -F \: '{print $1,$2}'


awk '!/^\s*#/'
```



## ceph



#### ceph -s 详解

```shell
watch -n1 ceph -s

Every 5.0s: ceph -s                          Thu Aug 18 11:13:51 2022

  cluster:
    id:     dfff3f17-f0d8-4e8a-9107-a68fb4eccffa
    health: HEALTH_WARN				# 健康状态
            9792109/98254284 objects misplaced (9.966%)
            Degraded data redundancy: 19944/98254284 objects degraded
 (0.020%), 105 pgs degraded, 187 pgs undersized

  services:
    mon: 3 daemons, quorum controller1,controller2,controller3	#三个守护进程，控制节点
    mgr: mon1_mgr(active), standbys: mon3_mgr, mon2_mgr	#活跃mon1_mgr	备用mon3_mgr	mon2_mgr
    osd: 115 osds: 115 up, 115 in; 1125 remapped pgs    # 115个OSD  115个状态为up 
    rgw: 6 daemons active          # 六个守护进程 都在运行

  data:
    pools:   11 pools, 5176 pgs
    objects: 32.75 M objects, 102 TiB
    usage:   352 TiB used, 513 TiB / 865 TiB avail
    pgs:     19944/98254284 objects degraded (0.020%)
             9792109/98254284 objects misplaced (9.966%)
             4049 active+clean
             813  active+remapped+backfill_wait
             125  active+remapped+backfilling
             104  active+recovery_wait+undersized+degraded+remapped
             77   active+recovering+undersized+remapped
             5    active+recovering+undersized
             2    active+recovery_wait+remapped
             1    active+recovery_wait+undersized+degraded

  io:
    client:   22 MiB/s rd, 200 MiB/s wr, 3.08 kop/s rd, 3.83 kop/s wr
    recovery: 98 MiB/s, 26 objects/s      #26 个对象在做恢复 速度为98 MiB/s
```





## Grep

grep Mount -A 10

除了列出符合行之外，并且列出后NUM行

grep Mount -B 10





## history

```shell
# history(选项)(参数)
选项:
-N: 显示历史记录中最近的N个记录；
-c：清空当前历史命令；
-a：将历史命令缓冲区中命令写入历史命令文件中；
-r：将历史命令文件中的命令读入当前历史命令缓冲区；
-w：将当前历史命令缓冲区命令写入历史命令文件中;
-d<offset>：删除历史记录中第offset个命令
-n<filename>：读取指定文件


# history 10
 1061  telnet 122.14.196.40 19091
 1062  telnet 122.14.196.40 9091
 1063  ls
 1064  df -hT
 1065  history -n 20
 1066  history 20
 1067  telnet 122.14.196.40 19091
 1068  ls
 1069  df -hT
 1070  history 10

使用  !number  执行第几条命令
# !1063
ls
1.txt  alertmanager.yml  prometheus_SD_.yml  prometheus.yml  rules  targets

执行上一条命令
# !!


用Ctrl+R搜索历史命令；当你执行了一串相当长的命令之后，你只要用关键字搜索一下历史命令然后重新执行这条命令而不需要将整条命令再输一遍
```

 

## http  status(状态码)：

```shell
	1xx:100-101,信息提示：
​	2xx：200-206，成功类信息
​	3xx：300-305，重定向
​	4xx：400-415，错误类信息，客户端错误
​	5xx：500-505，错误类信息，服务器端错误

常用的状态码：
	200：成功，请求的所有数据通过响应报文的entity-body部分发送：ok
	301：请求的URL指向的资源已经被删除，但在响应报文中通过首部Location指明了资源现在所处的新位置：Moved Permanently（永久删除）
	302：与301相似，但在响应报文中通过Location指明资源现在所处临时新位置；Found
	304：客户端发出了条件式请求；但服务器上的资源未曾发生改变，则通过响应此响应状态码通知客户端：Not Modified
	401：需要输入账号和面谬认证方能访问资源：Unauthorized
	403：请求被禁止：Firbidden
	404：服务器无法找到客户端请求的资源：Not Found
	500：服务器内部错误：Internal Server Error
	502：代理服务器从后端服务器收到了一条伪响应：Bad Gateway （很可能网关配置错误）
```





## KVM

```shell
查看虚拟机状态
virsh list  --all
查看虚机UUID
virsh list --all --uuid
启动虚机
virsh start 名称
```





## Openstack

#### 查询用户数据库底层在那个机器上

```shell
source admin-openrc.sh

# 通过用户的某一台虚机的openstack 底层IP，获取到用户的 project_id
openstack server show 底层IP			
openstack server list --project project_id 
```

#### 迁移云主机

```shell
source admin-openrc.sh
openstack server migrate  uuid --live computexx       --热迁移
openstack server show uuid

可进入容器内部通过命令查看虚机是否迁移完成
docker exec -it nova_libvirt sh
virsh list --all --uuid
```



## Ping丢包问题

**问题现象：zabbix 隔一段时间就提示ping报警，查看网络未发现什么异常**

**原因：**

内核参数 net.nf_conntrack_max 系统默认值为”65536”，当nf_conntrack模块被装置且服务器上连接超过这个设定的值时，系统会主动丢掉新连接包，直到连接小于此设置值才会恢复。同时内核参数“net.netfilter.nf_conntrack_tcp_timeout_established”系统默认值为”432000”，代表nf_conntrack的TCP连接记录时间默认是5天，致使nf_conntrack的值减不下来，丢包持续时间长。

解决方法：

修改net.nf_conntrack_max 值为2097152，然后使内核文件生效

```shell
cat /var/log/messages |grep nf_conntrac|wc -l

echo net.nf_conntrack_max = 2097152 >>/etc/sysctl.conf
sysctl -p
```

参考：`https://blog.csdn.net/weixin_45423952/article/details/112752962`























